#!/usr/bin/env bash

# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### TEXT WRITING AND DECORATION

## COLOR A PART OF A TEXT WITH ANOTHER COLOR.
## Pun between "deco(ration)" and "echo", followed by the first letter of the message type name (header (H), moving to a new sub-step (N), error (E) or success (S)).

function Decho() { local string=$1; echo "$COL_CYAN$string$COL_RESET"; }    # Colouring a part of a simple message written via the "echo" command.
function DechoE() { local string=$1; echo "$COL_CYAN$string$COL_RED"; }     # Error message
function DechoH() { local string=$1; echo "$COL_BLUE$string$COL_CYAN"; }    # Header text
function DechoN() { local string=$1; echo "$COL_CYAN$string$COL_YELLOW"; }  # New sub-step message
function DechoS() { local string=$1; echo "$COL_CYAN$string$COL_GREEN"; }   # Success message

# -----------------------------------------------

## DISPLAYING A MESSAGE ACCORDING TO THE CONTEXT AND THE "$MAIN_SCRIPT_LOG" VARIABLE VALUE.

# Error message
function EchoError() {
    #***** Parameters *****
    local string=$1
    local timer=$2
    
    #***** Code *****
    if test -z "$timer"; then
        timer=".5"
    fi
    
    if test -z "$MAIN_SCRIPT_LOG" || test -z "$FILE_LOG_PATH"; then
        echo "$TXT_R_TAB $string$COL_RESET"
    else
        CheckLog
        
        if test "$MAIN_SCRIPT_LOG" = "log"; then
            echo "$TXT_R_TAB $string$COL_RESET" >> "$FILE_LOG_PATH"
            
        elif test "$MAIN_SCRIPT_LOG" = "tee"; then
            echo "$TXT_R_TAB $string$COL_RESET" 2>&1 | tee -a "$FILE_LOG_PATH"
            
        else
            echo "EchoError : no valid write output mode defined"
        
            return
        fi
    fi

    sleep "$timer"
}

# New sub-step message
function EchoNewstep() { local string=$1; 
    #***** Parameters *****
    local string=$1
    local timer=$2
    
    #***** Code *****
    if test -z "$timer"; then
        timer=".5"
    fi
    
    if test -z "$MAIN_SCRIPT_LOG" || test -z "$FILE_LOG_PATH"; then
        echo "$TXT_N_TAB $string$COL_RESET"
    else
        CheckLog
        
        if test "$MAIN_SCRIPT_LOG" = "log"; then
            echo "$TXT_N_TAB $string$COL_RESET" >> "$FILE_LOG_PATH"
            
        elif test "$MAIN_SCRIPT_LOG" = "tee"; then
            echo "$TXT_N_TAB $string$COL_RESET" 2>&1 | tee -a "$FILE_LOG_PATH"
            
        else
            echo "EchoNewstep: no valid write output mode defined"
        
            return
        fi
    fi

    sleep "$timer"
}

# Success message
function EchoSuccess() { 
    #***** Parameters *****
    local string=$1
    local timer=$2

    #***** Code *****
    if test -z "$timer"; then
        timer=".5"
    fi
    
    if test -z "$MAIN_SCRIPT_LOG" || test -z "$FILE_LOG_PATH"; then
        echo "$TXT_S_TAB $string$COL_RESET"
    else
        if test "$MAIN_SCRIPT_LOG" = "log"; then
            echo "$TXT_S_TAB $string$COL_RESET" >> "$FILE_LOG_PATH"
            
        elif test "$MAIN_SCRIPT_LOG" = "tee"; then
            echo "$TXT_S_TAB $string$COL_RESET" 2>&1 | tee -a "$FILE_LOG_PATH"
            
        else
            echo "EchoSuccess : no valid write output mode defined"
            echo

            return
        fi
    fi

    sleep "$timer"
}


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### LINE BREAKS

## LINE BREAKS ACCORDING TO THE "$MAIN_SCRIPT_LOG" VARIABLE VALUE.

# Redirecting the output of the "echo" command
function Newline()
{
    if test -z "$MAIN_SCRIPT_LOG" || test -z "$FILE_LOG_PATH"; then
        echo
    else
        CheckLog
        
        if test "$MAIN_SCRIPT_LOG" = "log"; then
            echo "" >> "$FILE_LOG_PATH"
        elif
            echo "" 2>&1 | tee -a "$FILE_LOG_PATH"
        else
            echo "No valid write output mode defined"
        
            return
        fi
    fi
}
