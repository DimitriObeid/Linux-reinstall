#!/usr/bin/env bash

# ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; #

#################################### DEFINING LIBRARY FUNCTIONS ###################################

#### FILESYSTEM PERMISSIONS AND OWNING

## PERMISSIONS PROCESSING FUNCTIONS

function Chmod()
{

}

# -----------------------------------------------

## PROPERTY PROCESSING FUNCTIONS

# Fonctions d'attribution de propriété de fichier à l'utilisateur.

# Required files and functions :
#   - Echo.sh       -> EchoErrorTimer
#   - Echo.sh       -> EchoNewstepTimer
#   - Echo.sh       -> EchoSuccessTimer
#   - Headers.sh    -> DrawLine   
#   - Headers.sh    -> HandleErrors
function ChownFile()
{
    #***** Parameters *****
    

    #***** Code *****
    EchoNewstep "$MSG_MKFILE_CHMOD." "$timer"
	echo

    chown -v "$username" "$path"

    # On vérifie que les droits du fichier nouvellement créé ont bien été changés, en vérifiant le code de retour de la commande "chown".
    if test "$?" -eq "0"; then
        echo

        EchoSuccess "Les droits du fichier $(DechoS "$parent") ont été changés avec succès." "$sleep_txt"
        echo

        EchoSuccess "$MSG_MKFILE_PROCESSING_END_SUCC." "$timer"
        DrawLine "$COL_RESET" "$block_char"
        sleep "$sleep_blk"
        echo

        return
    else
        echo

        EchoError "Impossible de changer les droits du fichier $(DechoE "$path")." "$sleep_txt"
        EchoError "Pour changer les droits du fichier $(DechoE "$path")," "$sleep_txt"
        EchoError "utilisez la commande :" "$sleep_txt"
        echo "	chown username chemin"

        EchoError "$MSG_MKFILE_PROCESSING_END_FAIL." "$sleep_txt"
        DrawLine "$COL_RESET" "$block_char"
        sleep "$sleep_blk"
        echo

        return
    fi
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### FILES TREATMENT FUNCTIONS

# Fonction de création de fichiers 
# LORS DE SON APPEL, LA SORTIE DE CETTE FONCTION DOIT ÊTRE REDIRIGÉE SOIT VERS LE TERMINAL ET LE FICHIER DE LOGS, SOIT VERS LE FICHIER DE LOGS UNIQUEMENT.

# Required files and functions :
#   - Echo.sh       -> EchoErrorTimer
#   - Echo.sh       -> EchoNewstepTimer
#   - Echo.sh       -> EchoSuccessTimer
#   - Headers.sh    -> DrawLine   
#   - Headers.sh    -> HandleErrors
function Makefile()
{
	#***** Paramètres *****
	local parent=$1		# Emplacement depuis la racine du dossier parent du fichier à traiter.
	local name=$2		# Nom du fichier à traiter (dans son dossier parent).
	local sleep_blk=$3	# Temps de pause du script avant et après la création d'un bloc d'informations sur le traitement du fichier.
	local sleep_txt=$4	# Temps d'affichage des messages de passage à une nouvelle sous-étape, d'échec ou de succès.

	#***** Autres variables *****
	local path="$parent/$name"	# Chemin du fichier à traiter.
	local block_char="'"		# Caractère composant la ligne.

	#***** Code *****
	# On commence par dessiner la première ligne du bloc.
	sleep "$sleep_blk"
	DrawLine "$COL_RESET" "$block_char"

	EchoNewstep "$MSG_MILE_PROCESSING_BEGIN." "$sleep_txt"
	echo

	# Si le fichier à traiter n'existe pas, on le crée avec l'aide de la commande "touch".
	if test ! -f "$path"; then
        EchoNewstep "Création du fichier $(DechoN "$name") dans le dossier $(DechoN "$parent/")." "$sleep_txt"
		echo

		local lineno=$LINENO; touch "$path"

		# On vérifie que le fichier a bien été créé en vérifiant le code de retour de la commande "touch" via la fonction "HandleErrors".
        HandleErrors "$?" "LE FICHIER $(DechoE "$name") N'A PAS PU ÊTRE CRÉÉ DANS LE DOSSIER $(DechoE "$parent/")" "Essayez de le créer manuellement." "$lineno"
        EchoSuccess "Le fichier $(DechoS "$name") a été créé avec succès dans le dossier $(DechoS "$parent/")." "$sleep_txt"
        echo

		# On change les droits du fichier créé par le script.
		# Comme il est exécuté en mode super-utilisateur, tout dossier ou fichier créé appartient à l'utilisateur root.
		# Pour attribuer les droits de lecture, d'écriture et d'exécution (rwx) à l'utilisateur normal, on appelle
		# la commande chown avec pour arguments :
		#		- Le nom de l'utilisateur à qui donner les droits.
		#		- Le chemin du dossier cible.

		EchoNewstep "Changement des droits du nouveau fichier $(DechoN "$path") de $(DechoN "$USER") en $(DechoN "$ARG_USERNAME")." "$sleep_txt"
		echo

		chown -v "${ARG_USERNAME}" "$path"

		# On vérifie que les droits du fichier nouvellement créé ont bien été changés, en vérifiant le code de retour de la commande "chown".
		if test "$?" -eq "0"; then
			echo

			EchoSuccess "Les droits du fichier $(DechoS "$parent") ont été changés avec succès." "$sleep_txt"
			echo

			EchoSuccess "$MSG_FILE_PROCESSING_END_SUCC." "$sleep_txt"
			DrawLine "$COL_RESET" "$block_char"
			sleep "$sleep_blk"
			echo

			return
		else
			echo

			EchoError "Impossible de changer les droits du fichier $(DechoE "$path")." "$sleep_txt"
			EchoError "Pour changer les droits du fichier $(DechoE "$path")," "$sleep_txt"
			EchoError "utilisez la commande :" "$sleep_txt"
			echo "	chown ${ARG_USERNAME} $path"

			EchoError "$MSG_FILE_PROCESSING_END_FAIL." "$sleep_txt"
			DrawLine "$COL_RESET" "$block_char"
			sleep "$sleep_blk"
			echo

			return
		fi
	
	# Sinon, si le fichier à créer existe déjà ET qu'il n'est pas vide.
	elif test -f "$path" && test -s "$path"; then
		EchoNewstep "$MSG_FILE_NONEMPTY_1." "$sleep_txt"
		EchoNewstep "$MSG_FILE_NONEMPTY_2." "$sleep_txt"
		echo

		true > "$path"

		# On vérifie que le contenu du fichier cible a bien été supprimé en testant le code de retour de la commande "true".
		if test "$?" -eq "0"; then
			EchoSuccess "$MSG_FILE_NONEMPTY_SUCC." "$sleep_txt"
			echo

			EchoSuccess "$MSG_FILE_PROCESSING_END_SUCC." "$sleep_txt"
			DrawLine "$COL_RESET" "$block_char"
			sleep "$sleep_blk"
			echo
        else
            EchoError "$MSG_FILE_NONEMPTY_FAIL." "$sleep_txt"
			echo

			EchoError "$MSG_FILE_PROCESSING_END_FAIL." "$sleep_txt"
			DrawLine "$COL_RESET" "$block_char"
			sleep "$sleep_blk"
			echo
		fi

		return

	# Sinon, si le fichier à créer existe déjà ET qu'il est vide.
	elif test -f "$path" && test ! -s "$path"; then
		EchoSuccess "$MSG_MKFILE_EMPTY." "$sleep_txt"
		echo

		EchoSuccess "$MSG_MKFILE_PROCESSING_END_SUCC." "$sleep_txt"
		DrawLine "$COL_RESET" "$block_char"

		return
	fi
}

# -----------------------------------------------


# /////////////////////////////////////////////////////////////////////////////////////////////// #

#### FONCTIONS DE TRAITEMENT D'ARCHIVES
# Décompression des archives des logiciels selon la méthode de compression utilisée (voir la fonction "SoftwareInstall").
function UncompressArchive()
{
    #***** Paramètres *****
    cmd=$1     # Commande de décompression propre à une méthode de compression.
    option=$2  # Option de la commande de décompression (dans le cas où l'appel d'une option n'est pas obligatoire, laisser une chaîne de caractères vide lors de l'appel de la fonction).
    path=$3    # Chemin vers l'archive à décompresser.
    name=$4    # Nom de l'archive.

    #***** Code *****
    # On exécute la commande de décompression en passant en arguments ses options et le chemin vers l'archive.
    "$cmd $option $path"

    HandleErrors "$?" "LA DÉCOMPRESSION DE L'ARCHIVE $(DechoE "$name") A ÉCHOUÉE"
    
    EchoSuccess "La décompression de l'archive $(DechoS "$name") s'est effectuée avec brio."
    Newline
}
